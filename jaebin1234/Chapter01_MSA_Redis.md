# 1장: 마이크로 서비스 아키텍처와 레디스

---

## 모놀리틱 아키텍처 (Monolithic Architecture)
- 하나의 큰 애플리케이션 안에 모든 기능이 포함된 구조 
- 예를 들어, 하나의 큰 어플리케이션 안에 로그인, 회원가입, 결제, 주문, 포인트, 피드, 상품 관리, 채팅 등 여러 서비스가 포함된다.

<details>
<summary>장점</summary>

1. 초기 구축이 빠름
   - 스타트업에서 빠르게 MVP(최소 기능 제품)를 만들어 고객에게 빨리 배포하려고 할 때 유리함.
   - 하나의 서버 안에서 코드로 연결되어 있어서 복잡한 네트워크 설정 없이 빠르게 개발하고 배포 가능
   - 예시 
      - 스타트업인 쇼핑몰 회사가 MVP로 간단한 온라인 쇼핑 서비스를 2주 만에 출시
2. 유지 관리 단순
   - 하나의 프로젝트 코드베이스만 관리하면 되기 때문에 기능 추가나 코드 변경, 장애처리가 쉬움
   - 개발자들이 한눈에 전체적인 기능 흐름을 쉽게 파악하고 유지보수하기 쉬움
   - 예시
      - 쇼핑몰 회사에서 오류가 발생했을 때, 모든 기능이 한 곳에서 관리되므로 개발자가 애플리케이션 로그와 코드를 빠르게 점검해서 쉽게 문제를 파악하고 수정가능
</details>

<details>
<summary>단점</summary>

1. 확장성 제한적
   - 사용자가 늘어나 특정 기능(예: 결제)이 과부하가 걸릴 경우, 모놀리틱 아키텍처에서는 기능을 개별적으로 확장하기 어렵고 전체 서버를 확장해야 하므로 비용과 효율성이 떨어짐
   - 예시
      - 쇼핑몰 사용자가 급격히 늘면서 결제 부분의 부하가 심해졌어. 하지만 모놀리틱 구조라 결제 부분만 따로 확장할 수 없어서 서버 전체를 증설해야 함
2. 배포 어려움
   - 작은 기능 하나만 바꿔도 전체 애플리케이션을 재배포해야 하므로 서비스 배포 시간이 길어지고, 문제가 발생할 가능성도 높아짐
   - 예시
      - 쇼핑몰에 작은 디자인 수정이 발생했을때, 작은 수정 사항임에도 전체 애플리케이션을 다시 빌드하고 배포해야 했기 때문에 긴 배포 시간 동안 서비스가 멈추거나 배포 중 에러가 발생해서 전체 서비스에 영향을 끼침
3. 시스템 장애 전파가 빠름
   - 하나의 기능에서 발생한 장애가 애플리케이션 전체로 빠르게 전파되어 전체 서비스가 중단될 수 있음
   - 예시
     - 상품 페이지에서 오류가 발생했는데, 이 오류가 전체 서버를 다운시켜서, 회원가입이나 결제, 고객센터 등과 같은 전혀 다른 기능들까지 사용할 수 없게 됨
</details>

### ❓질문
1. 빅뱅 배포란?
   - 전체 애플리케이션을 한 번에 빌드하고 배포하는 방식을 의미합니다. 기능의 일부만 수정해도, 전체 시스템을 다시 배포해야 하는 구조입니다.
   - 예시
     - 한 쇼핑몰 회사의 모놀리식 구조이고, 로그인, 결제, 상품 조회, 리뷰 기능이 전부 하나의 코드베이스로 묶여있음
     - 단순한 수정임에도 불구하고 전체 서비스를 빌드하고 배포함.
     - 혹시 모를 장애에 대비하기 위해 새벽 2시부터 5시까지 배포 시간을 잡고 작업을 진행함.
     - 배포 도중 오류가 발생하면 전체 서비스를 롤백함.
---

## 마이크로서비스 아키텍처 (Microservices Architecture)
- 애플리케이션을 작고 독립적인 서비스로 분할하여 개발 및 운영
- 예를 들어, 로그인 서비스, 결제 서비스, 주문 서비스 각각 독립적인 서비스로 분할 및 개발 할 수 있다.

<details>
<summary>장점</summary>

1. 독립적 확장성
   - 서비스마다 개별적인 확장이 가능하여, 필요한 서비스만 리소스를 추가할 수 있어 효율적임
   - 예시
      - 영상 재생 서비스와 댓글 서비스가 별도의 마이크로서비스로 구성되어 있을 경우, 갑자기 사용자가 늘어 댓글 서비스에만 부하가 생겼을 때, 댓글 서비스만 별도의 서버 인스턴스를 추가로 늘려 확장 할 수 있음. 이로써 다른 서비스(예: 영상 서비스)의 리소스를 낭비하지 않음
2. 빠른 배포
   - 각 서비스가 독립적인 팀이 개발하고 배포하기 때문에 배포 속도가 빨라지고, 전체 서비스에 미치는 영향이 줄어듦
   - 예시
      - 이커머스 서비스에서 결제와 상품 추천 서비스가 독립적으로 운영 중 일 경우,상품 추천 서비스에 간단한 알고리즘 변경이 있었을 때, 추천 서비스만 빠르게 배포할 수 있었기 때문에 서비스 중단 없이 빠른 업데이트가 가능
3. 장애 격리 용이
    - 특정 서비스에서 장애가 발생해도 독립적인 서비스로 격리되어 있어 전체 시스템에 미치는 영향이 최소화됨
    - 예시
       - 여행 예약 시스템에서 항공권 예약 서비스에 장애가 발생했지만, 호텔 예약 서비스, 렌터카 서비스는 마이크로서비스로 분리되어 있어 항공권 서비스만 잠시 중단하고 나머지 서비스는 정상 운영할 수 있음
</details>

<details>
<summary>단점</summary>

1. 분산 시스템 복잡성 증가
   - 여러 개의 서비스가 서로 통신하면서 복잡도가 높아지고 서비스 관리 및 디버깅이 어려워질 수 있음
   - 예시
      - 온라인 쇼핑몰의 주문 프로세스가 주문, 결제, 재고관리로 각각 분리되어 있을 때,주문 실패가 일어나면 정확히 어느 서비스에서 장애가 발생했는지 추적하려면 여러 서비스 간의 로그와 통신 과정을 모두 점검해야 해서 디버깅 시간이 길어짐
2. 데이터 일관성 관리 어려움
   - 서비스별로 독립된 데이터 저장소를 가지므로, 데이터 간 일관성 유지가 어려워지고 트랜잭션 관리가 복잡해짐
   - 예시
      - 이커머스 플랫폼에서 주문 서비스와 재고 서비스가 각각 독립된 마이크로서비스로 구성되어 있었어. 사용자가 상품을 결제하면 주문은 성공했지만, 재고 차감 요청이 실패해서 실제로는 재고가 없는데 주문이 접수되는 문제가 발생할 수 있음
3. 에러 발생 시 복구와 일관성 유지 복잡성
   - 여러 서비스가 얽혀 있기 때문에 하나의 서비스에서 에러가 발생하면, 전체 시스템의 상태를 정상적으로 복구하고 일관성을 유지하기 위한 추가적인 노력이 필요해짐
   - 예시
     - 영화 티켓 예매 서비스에서 좌석 예약과 결제 서비스가 나누어져 있을 때, 결제는 완료되었으나 좌석 예약이 실패했을 때, 결제 상태를 되돌리고 좌석 예약을 취소하는 작업이 필요했는데, 서비스가 분산되어 있어서 복구 절차가 복잡하고 어렵게 됨
</details>

### ❓질문
1. 서킷 브레이커란?
   - MSA에서 서비스 간 통신에서 호출 대상 서비스가 장애 상태일 경우 계속 요청을 보내면 전체 시스템이 느려지거나 장애가 전파될 수 있습니다. 
   - 이를 막기 위해 일정 시간 동안 호출을 차단하고 빠르게 실패하게 만드는 보호 장치가 서킷 브레이커입니다.
   - 동작방식
      - 일정 횟수 이상 실패 시 회로를 “열림(Open)” 상태로 바꿔 이후 요청은 바로 실패 처리 
      - 일정 시간 이후 “반열림(Half-Open)” 상태로 일부 요청을 시도 
      - 성공하면 다시 “닫힘(Closed)” 상태로 복귀
   - 예시
      - 주문 서비스가 결제 서비스에 요청할 때, 결제 서비스가 장애 상태라면 서킷 브레이커가 요청을 즉시 실패로 처리하고 우회로(예: 메시지 큐 저장 등)를 선택하여 전체 서비스의 지연을 방지
2. 아웃박스 패턴이란?
   - MSA 환경에서는 데이터베이스와 메시지 브로커(Kafka 등)에 동시에 데이터를 일관되게 반영해야 할 필요가 자주 발생합니다.
   - 하지만 DB 트랜잭션과 메시지 전송은 분산 환경에서는 동시에 보장되지 않기 때문에 데이터 일관성이 깨질 위험이 있습니다.
   - 이를 해결하기 위해 DB 내 Outbox 테이블에 먼저 데이터를 저장하고, 이후 별도의 프로세스(예: Polling 또는 Debezium CDC)를 통해 메시지 브로커로 전송합니다.
   - 동작방식
      - 비즈니스 트랜잭션과 함께 Outbox 테이블에 이벤트 기록
      - 이벤트 발송기는 Outbox 테이블을 주기적으로 읽고 Kafka 등으로 발행
      - 전송 성공 시 Outbox 레코드를 삭제 또는 상태 업데이트
   - 예시
      - 결제 성공 후 Kafka로 “결제완료” 이벤트를 전파할 때, Outbox 테이블에 먼저 기록하여 DB와 Kafka 간 데이터 손실이나 순서 오류를 방지
3. 사가 패턴 이란?
   - MSA에서 하나의 비즈니스 트랜잭션이 여러 서비스에 걸쳐 이루어질 경우, 분산 트랜잭션 대신에 각 서비스가 로컬 트랜잭션을 수행하고, 다음 서비스를 호출하거나 보상 트랜잭션을 실행하는 방식으로 데이터 일관성을 유지하는 패턴입니다.
   - 구성 방식
      - Choreography 방식: 이벤트 기반으로 다음 서비스를 호출 (서비스 간 느슨한 결합)
      - Orchestration 방식: 중앙 서비스가 흐름을 제어 (더 명확한 흐름 통제)
   - 예시
      - 사용자가 주문을 생성할 때, 먼저 포인트를 차감한 후 결제, 배송 등의 후속 프로세스를 진행합니다. 만약 결제 단계에서 실패하면, 보상 트랜잭션을 통해 차감된 포인트를 복원해야 합니다.
4. 보상 트랜잭션이란?
   - 분산 시스템(특히 MSA)에서 하나의 전체 트랜잭션이 여러 서비스에 걸쳐 수행될 때, 일부 서비스에서 실패가 발생했을 경우, 앞서 성공한 트랜잭션의 결과를 "논리적으로 취소"하기 위해 수행하는 별도의 트랜잭션입니다.
   - 완료된 작업을 되돌리는 별도의 동작을 명시적으로 구현한 것
   - 예시
     - 주문 서비스: 주문 정보 저장 → 성공 
     - 포인트 서비스: 포인트 차감 → 성공 
     - 결제 서비스: 카드 결제 요청 → 실패
     - 이때, 이미 성공한 "포인트 차감", "주문 정보 저장"에 대해 보상 트랜잭션으로 포인트를 다시 복원해야 합니다.

---
## NoSQL이란?
- 고정된 스키마 없이 대규모의 데이터를 유연하고 확장성 있게 저장하고 처리할 수 있도록 설계된 비관계형 데이터베이스입니다.
- 관계형 데이터베이스의 한계를 극복하기 위한 데이터 저장소.
- NoSQL의 특징
  - **실시간 응답**: 빠른 속도
      - 모든 데이터를 메모리에 저장하거나, 디스크 접근 없이 빠르게 응답할 수 있도록 설계됨.
      - 예시
        - 레디스(Redis)를 캐시로 사용하는 웹 애플리케이션에서 사용자 프로필을 조회할 때,→ DB 조회 없이 레디스에서 바로 응답하여 1ms 이내에 처리.
        실시간 랭킹, 실시간 알림, 실시간 검색 자동완성 등에 사용.
  - **확장성**: 수평적 확장 가능
      - 서버를 추가하여 처리량 증가 (scale-out).
      - MongoDB, Cassandra, Elasticsearch는 노드를 추가해서 수평적으로 데이터를 분산 저장함.
      - 예시
        - 트위터는 유저 데이터를 Cassandra 기반으로 수평 확장하여 저장.→ 사용자 수가 급증해도 장애 없이 운영 가능
      - MongoDB는 샤딩(sharding)을 통해 수십억 건의 데이터를 여러 서버에 나눠 저장하고 조회 가능.
  - **고가용성**: 장애 대비 설계
      - 데이터 복제(replication), 자동 failover 등을 통해 항상 접근 가능하게 유지.
      - Redis Sentinel은 마스터 장애 시 자동으로 슬레이브를 승격해 무중단 서비스를 유지
  - **클라우드 네이티브**: 클라우드 환경에 적합
      - 클라우드 환경에 최적화되어 자동 확장, 복제, 백업, 모니터링 등 관리가 쉬움.
      - MongoDB Atlas, Google Firestore, Amazon DynamoDB는 클라우드 기반 NoSQL 서비스로서버 관리 없이도 대규모 트래픽과 데이터 증가에 자동 대응 가능
  - **단순성**: 간단한 데이터 모델
      - 관계형처럼 JOIN, 복잡한 트랜잭션 없이도 필요한 데이터를 간단하게 저장하고 조회 가능.
      - MongoDB에서 블로그 글과 댓글을 하나의 문서(document)에 함께 저장하여,글과 댓글을 한 번의 쿼리로 바로 조회
  - **유연성**: 스키마가 없는 구조로 변경 쉬움
      - 각 데이터마다 구조가 달라도 삽입 가능. 필드 추가나 변경 시 테이블을 수정할 필요 없음.
      - 예시
        - user 컬렉션에 저장된 각 유저 문서에 서로 다른 필드 존재:
          - userA: { email, nickname, age }
          - userB: { email, joinedAt, isAdmin }→ 자유롭게 데이터 구조 설계 및 진화 가능.

---
## NoSQL 데이터 저장소에는 어떤 유형이 있는가?

| 유형 | 대표 DB | 저장 구조 | 특징 | 적합한 용도 |
| --- | --- | --- | --- | --- |
| **문서 기반 (Document)** | MongoDB, CouchDB | JSON/BSON 기반 문서 단위 저장 | 유연한 스키마, 객체 형태와 유사 | 전자상거래, 유저 프로필, CMS |
| **키-값 기반 (Key-Value)** | Redis, DynamoDB | Key에 대응하는 Value만 저장 | 단순하고 빠른 조회, 구조 없음 | 세션 저장, 캐싱, 순위 저장 |
| **컬럼 기반 (Column-family)** | Cassandra, HBase, ScyllaDB | 같은 컬럼끼리 묶어서 저장 | 열 단위 저장 → 특정 열만 빠르게 조회 | 로그, 이벤트 분석, IoT, 타임시리즈 |
| **그래프 기반 (Graph)** | Neo4j, JanusGraph | 노드 + 엣지(관계) 형태의 구조 | 관계 기반 탐색과 분석에 최적화 | 추천 시스템, 경로 탐색, 소셜 네트워크 분석 |