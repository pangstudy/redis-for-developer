# 4장: 레디스 자료구조 활용 사례

---

## Sorted Set 활용 사례 및 예시

### 실시간 리더보드 서비스
- 듀오링고, 말해보카 같은 서비스에서 사용자 간 경쟁을 유도하기 위한 실시간 랭킹 구현
- 게임에서 플레이어 점수를 기준으로 한 실시간 순위 제공
- **절대적 리더보드**: 전체 사용자 중 절대 점수 기준
- **상대적 리더보드**: 특정 사용자 주변 순위를 기준
- **실시간 리더보드 서비스에서 Redis의 강점** : 
  - 데이터가 실시간으로 갱신 가능하며, 속도가 매우 빠르다.
  - 자동 정렬 지원으로 실시간 랭킹 구현 용이
- 활용 예시
```
# 사용자 점수 추가 또는 업데이트
ZADD leaderboard 250 user:1234

# 상위 10명 조회
ZREVRANGE leaderboard 0 9 WITHSCORES

# 특정 사용자 점수 증가
ZINCRBY leaderboard 50 user:1234

# 여러 기간의 점수를 합산하여 주간 리더보드 생성
ZUNIONSTORE weeklyLeaderboard 7 day1 day2 day3 day4 day5 day6 day7 WEIGHTS 1 1 1 1 1 1 1
```
- ❓관계형 DB를 사용할 경우 문제점
  - 데이터를 매번 재정렬하거나 복잡한 집계 쿼리 필요
  - 데이터량이 많아지면 성능이 급격히 저하
- 예시:
  - 점수 순 정렬 쿼리의 성능 저하
    - 점수 변경이 자주 발생하면, 정렬을 위한 인덱스 재작성 비용 증가
    - 수십만~수백만 건의 데이터가 있을 경우, 정렬 성능 급하락  
  - 특정 유저의 현재 순위 계산의 어려움
    - WHERE score > ...로 전수 비교 → O(n) 연산
    - 실시간 성능 요구가 높은 환경에서 적절하지 않음
  - 기간별 리더보드 집계의 복잡성
    - GROUP BY, ORDER BY, SUM 등 집계 쿼리가 복잡하고 무거움
    - 매번 집계 수행 시 DB I/O 부하 발생
  - 랭킹 업데이트의 병목
    - 다수 유저가 점수를 동시에 획득하면, 업데이트 쿼리가 몰리면서 락 발생 가능
    - 실시간 반영 어려움 → 배치 처리 필요해 실시간성이 떨어짐

### 최근 검색 기록 저장하기
- 중복 제거, 최근 5개만 저장, 사용자별 독립적 관리
- Sorted Set의 점수로 timestamp 활용 가능, 자동 정렬
- 음수 인덱스로 오래된 데이터 자동 삭제 용이
- 활용 예시
```
# 검색 키워드 추가 (중복제거 자동처리, 시간기반 최신순)
ZADD recentSearch:user123 1716880000 "redis 강의"

# 최근 5개 키워드 조회
ZREVRANGE recentSearch:user123 0 4

# 최근 5개 초과한 데이터 삭제
ZREMRANGEBYRANK recentSearch:user123 0 -6
```
- ❓관계형 DB를 사용할 경우 문제점
- 조회할 때마다 정렬 쿼리 수행, 중복 제거 별도 처리 필요
- 예시
  - 중복 제거 및 갱신 처리의 복잡성
    - 중복 방지를 위해 매번 `DELETE + INSERT` 처리 필요 → I/O 증가
    - 트랜잭션 처리 또는 UPSERT 필요 → **로직 복잡화**
  - 최신순 정렬 및 조회 성능 저하
    - 인덱스가 없다면 정렬 비용이 매우 큼
    - 검색 기록이 많을수록 성능 저하
  - 5개 초과 데이터 삭제 처리
    - **서브쿼리 사용**으로 인해 쿼리 복잡, 성능 이슈 발생 가능
    - 많은 유저가 동시에 기록을 남기면 서버 부하 급증

- ❓음수 인덱스를 이용한 데이터 삭제가 용이한 이유는 뭘까?
  - Sorted Set은 항상 점수로 자동 정렬되어 최신 데이터가 맨 뒤에 위치합니다.
  - 음수 인덱스를 사용하면 가장 최근 데이터를 역순으로 쉽게 접근하고 삭제할 수 있습니다.
  - 관계형 DB와 달리 복잡한 정렬 및 추가 연산 없이, 최근 데이터 유지 및 오래된 데이터 삭제가 효율적으로 가능합니다.

### 태그 기능 구현하기
- 자료 구조가 Set이므로 중복을 자동으로 방지함
- 다중 태그의 교집합, 합집합 등 연산 지원
- 관계형 DB의 N:M 관계를 효과적으로 구현 가능
- 활용 예시
```
# 게시물에 태그 추가
SADD post:1234:tags Redis Java Spring

# 태그가 있는 게시물 추가
SADD tags:Redis:post 1 2 3

# 특정 태그가 있는 모든 게시물 조회
SMEMBERS tag:Redis

# 여러 태그를 모두 가진 게시물 찾기
SINTER tag:Redis tag:Spring
```
- ❓관계형 DB를 사용할 경우 문제점
  - 태그를 별도의 조인 쿼리 없이 빠르게 처리
  - 대량 데이터의 경우 Redis가 압도적으로 빠른 성능 제공
  - 예시
    - N:M 관계 테이블 설계 필요
      - 3개의 테이블과 **조인(join)**을 항상 요구함
      - 삽입/삭제 시 관계 테이블 관리가 번거롭고 비용 발생
    - 특정 태그가 달린 게시물 조회 시 JOIN 성능 저하
      - 1개의 태그는 괜찮지만, 여러 태그를 필터링할 경우 조인 + WHERE 조건이 복잡해지고,
      - 대규모 데이터에서는 쿼리 최적화 필수, 인덱스 없으면 속도 급감

## Redis의 다양한 카운팅 방법

### 좋아요 처리하기
- 중복 처리 간편 (중복 좋아요 방지)
- 좋아요 개수 조회가 매우 빠름
- 활용 예시
```
# 좋아요 처리 (중복 방지)
SADD likes:post1234 user5678

# 좋아요 수 조회
SCARD likes:post1234
```
- ❓관계형 DB를 사용할 경우 문제점
  - N:M 관계 테이블 설계 필요
  - 좋아요 수를 업데이트 하는 방식이라면,
    - 업데이트 발생 때마다 데이터 경합으로 인해 성능 저하
    - 많은 수의 좋아요 동시 처리 시 데이터 락(lock) 문제 발생 가능

### 읽지 않은 메시지 수 카운팅
- 사용자별, 채널별 메시지 수를 간단히 저장, 빠르게 증가 가능
- 활용 예시
```
# 읽지 않은 메시지 수 증가
HINCRBY unread:user123 messages:channel456 1

# 읽지 않은 메시지 수 확인
HGET unread:user123 messages:channel456
```
- ❓java에서 사용하기 좋은 방향
```
HSET unread:user123 channel456 '{"count":3,"type":"message"}'
```
```
# 키: unread:user123
# 필드: channel456
# 값: {"count":3,"type":"message"}

{
  "channel456": "{\"count\":3,\"type\":\"message\"}",
  "channel789": "{\"count\":1,\"type\":\"alarm\"}",
  "channel999": "{\"count\":0,\"type\":\"message\"}"
}
```

### DAU(하루동안 방문자 수) 계산하기
- Bitmaps 사용
- 메모리 효율적 사용 (대규모 유저 관리)
- 빠른 비트 연산으로 카운팅 성능 뛰어남
- 활용 예시
```
# 사용자 방문 처리
SETBIT dau:20240529 userId(123) 1

# DAU 조회
BITCOUNT dau:20240529

# 특정 기간 동안 연속 방문자 추적
BITOP AND dau:week dau:day1 dau:day2 dau:day3 dau:day4 dau:day5 dau:day6 dau:day7
BITCOUNT dau:week
```
```
# 시각적 예시
인덱스:   0  1  2  3  ... 123 ...
값:      0  0  0  0       1
```

### HyperLogLog로 월별 API 호출 카운트하기
- 정확한 카운팅이 아닌 근사값이 허용되는 경우 매우 빠르고 효율적
- 메모리 사용량이 극도로 적음
- 활용 예시
```
# 사용자 API 호출 기록
PFADD apiCalls:202405 user:1234

# 월별 사용자 카운트 조회
PFCOUNT apiCalls:202405
```

## 위치 기반 애플리케이션

### Geospatial Index 사용 이유
- 위치정보 저장 및 근접한 사용자 조회 가능
- 실시간 위치기반 이벤트 처리 가능 (맛집 주변 사용자 실시간 알림 등)
- 활용 예시
```
# 위치 추가
GEOADD restaurants 127.0016985 37.5642135 "치킨집"

# 특정 위치 주변 사용자 찾기
GEOSEARCH users FROMLONLAT 127.0016985 37.5642135 BYRADIUS 500 m

# 멤버 중심 근처 사용자 찾기
GEOSEARCH users FROMMEMBER "치킨집" BYRADIUS 500 m
```
- ❓위치 데이터 수집 → 분석 → 사용자 알림 과정은 어떻게 될까?
1. 위치 정보 수집 (Client → Backend)
   - 위치는 위도/경도로 주기적으로 백엔드에 전송
   - REST API or WebSocket을 통해 서버에 전달
2. 위치 저장 및 인덱싱
   - Redis GEO: 간단하고 빠른 근접 검색
   - PostGIS (PostgreSQL extension)
   - 사용자별로 최신 위치만 저장하거나, 시간별 이력을 저장
3. 근처 이벤트 감지 및 푸시 처리
   - 사용자가 특정 지역 반경에 도달하면 → 서버가 판단하여 알림 전송
   - 서버가 Redis GEOSEARCH로 근처 이벤트 감지
4. 예시
   - 사용자가 10초~1분 간격으로 현재 위치를 앱이 서버에 전송 
   - 서버는 해당 위치를 Redis GEO에 GEOADD로 저장 
   - 전송 받은 위치에 대해 GEOSEARCH로 반경 내 타겟(맛집, 광고 등) 검색 
   - 근처에 타겟이 있으면 → FCM, APNS, WebSocket 등으로 푸시 전송