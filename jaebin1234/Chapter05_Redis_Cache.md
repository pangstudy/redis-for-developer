# 5장: 레디스를 캐시로 사용하기
---

## 레디스와 캐시 개요
- 캐시란? : 캐시란 자주 사용하는 데이터를 빠르게 접근하기 위해 임시로 저장해두는 저장소입니다.
- 캐시 도입 만족 조건
  - 원본 데이터 조회가 느리거나 자주 연산이 필요한 경우
  - 캐시 조회 속도가 원본보다 빨라야 함
  - 저장된 데이터가 자주 사용되고 변동이 적어야 함
- 캐시로서의 레디스
  - 다양한 자료구조를 변환 과정 없이 바로 활용 가능
  - 빠른 I/O 처리 속도 (평균 1ms 미만)
  - 고가용성 지원 (복제, 클러스터)

## 레디스 캐싱 전략

### 캐시 히트
- 클라이언트가 요청한 데이터가 Redis 캐시에 존재하여 바로 반환되는 경우
- 빠른 응답 속도, DB 접근 불필요 → 성능 향상

### 캐시 미스
- 클라이언트가 요청한 데이터가 Redis에 없어서, DB에서 조회한 후 Redis에 다시 저장하는 경우

### 캐시 불일치
- Redis 캐시와 DB의 데이터가 서로 다른 값을 가지고 있는 상태
- DB만 업데이트하고 캐시를 갱신하지 않음
- 캐시 삭제보다 먼저 DB를 수정하고, 중간에 실패 발생
- TTL 만료 후 오래된 값이 다시 캐싱되는 경우 등


### 읽기 전략
- Look-aside(Cache-aside) 전략
  - 캐시에 없는 경우 DB에서 조회 후 캐시에 저장
  - 장점
    - 구현 간단
    - 자주 사용되는 데이터만 캐시
  - 단점
    - 최초 요청 시 Cache Miss 발생
    - 캐시와 DB의 데이터 불일치 가능성 존재
      -  쓰기 후 캐시 삭제 실패
        - DB는 성공적으로 업데이트
        - Redis에서 DEL 명령이 네트워크 장애 등으로 실패
        - 캐시에 오래된 데이터가 남아 있음
      - 동시성 문제 (Race Condition)
        - Thread A: 캐시 미스 → DB 조회 → Redis에 저장
        - Thread B: 같은 시점에 DB를 업데이트하고 캐시 삭제
        - Thread A가 DB의 오래된 값을 다시 Redis에 넣음
  - 해결 방안
    - 캐시 워밍
      - 서비스 시작 시 미리 캐시를 채워놓는 전략
      - Cache Miss를 최소화하여 성능 최적화

### 쓰기 전략
- Write-through 전략
  - 캐시와 DB 동시에 쓰기 수행 (즉시 일관성 유지)
  - 장점
    - 캐시와 DB의 높은 일관성 보장
  - 단점
    - 쓰기 성능 저하:
      - 두 번 쓰기(DB + Redis) → 응답 시간 증가
      - Redis 또는 DB 중 하나가 느려지면 전체 트랜잭션 지연
    - 트랜잭션 처리 어려움:
      - 캐시와 DB 간 동기화 실패 시 일관성 문제 발생 가능
- Cache Invalidation 전략
  - 데이터 변경 시 캐시의 데이터를 삭제하여 일관성 유지
  - 다음 읽기 요청에서 DB → 캐시 재적재
  - 장점
    - 데이터 일관성 유지 간편
    - 불필요한 캐시 데이터 방지
  - 단점
    - Cache Miss 빈번히 발생 가능성 (읽기 성능 저하)
    - 삭제 실패 또는 순서 꼬임 → 캐시 불일치
- Write-behind 전략
  - 캐시에만 데이터 쓰고, 일정 주기로 DB에 비동기적으로 반영
  - 쓰기가 많은 경우 유용함
  - 장점
    - 쓰기 성능 뛰어남 (DB 부담 감소)
  - 단점
    - redis 장애 시 데이터 손실 가능성 (일관성 관리 복잡)

### 캐시 데이터 관리 (TTL)
- TTL 이란?
  - 특정 키(key)에 대해 **얼마나 오래 살아있을지(유효할지)**를 설정하는 기능
  - 데이터가 만료되면 Redis에서 자동 삭제
  - 메모리 관리에 중요함
  - `EXPIRE`, `PEXPIRE`: 키의 만료시간 설정
  - `TTL`, `PTTL`: 키의 남은 만료시간 확인
- Redis의 만료 키 삭제 방식
  - Passive Expiration (수동 만료 / Lazy 방식)
    - 키에 접근할 때, 그제서야 만료 여부를 확인하는 방식입니다.
    - 클라이언트가 해당 키를 GET, HGET 등으로 조회 시점에 Redis가 "이 키의 TTL이 지났는가?"를 체크 
    - 만약 만료되었다면: 키를 즉시 삭제하고 → nil 또는 존재하지 않음 응답
    - 장점: 불필요한 키 스캔 안 함 → CPU 효율적
    - 단점: 접근이 없는 키는 삭제되지 않고 계속 메모리에 남아 있음
  - Active Expiration (능동 만료 / Background 방식)
    - Redis는 매 100ms마다 일부 샘플 키를 랜덤하게 검사
    - 만료된 키를 발견하면 즉시 삭제
    - 시간이 지나도 접근되지 않는 오래된 키도 eventually 삭제됨
    - 장점: 접근되지 않는 키도 자동 삭제됨
    - 단점: 샘플링 기반이므로 모든 키가 즉시 삭제되지는 않음
    
### 메모리 관리와 정책(maxmemory-policy)
- Redis에서 사용할 수 있는 최대 메모리 설정
- 최대 메모리 도달 시 적용할 삭제 정책 설정
- ❓왜 Redis에서 메모리 관리를 해야 하나요?
  - 모든 데이터는 RAM에 저장되므로 디스크보다 빠르지만, 용량이 제한적입니다.
  - Redis는 빠른 응답을 제공하지만, 동시에 수많은 요청으로 인해 메모리가 가득 차면 쓰기 차단, 지연, 또는 장애 발생 가능
  - 오래된 데이터, 접근하지 않는 데이터는 제거해야 메모리를 효율적으로 재사용 가능

| 정책명 | 설명 |
| --- | --- |
| `noeviction` | 메모리 초과 시 오류 반환 |
| `volatile-lru` | 만료 설정된 키 중 가장 오랫동안 미사용한 키 삭제 |
| `allkeys-lru` | 모든 키 중 가장 오랫동안 미사용한 키 삭제 |
| `volatile-lfu` | 만료 설정된 키 중 사용 빈도가 낮은 키 삭제 |
| `allkeys-lfu` | 모든 키 중 사용 빈도가 낮은 키 삭제 |
| `volatile-random` | 만료 설정된 키 중 무작위 삭제 |
| `allkeys-random` | 모든 키 중 무작위 삭제 |
| `volatile-ttl` | 만료 시간이 임박한 키 삭제 |

- 보통은 allkeys-lru, volatile-lru, allkeys-lfu를 자주 사용

### 캐시 스탬피드 현상
- 동일한 키에 대한 캐시가 비어 있거나 만료되었을 때, 여러 요청이 동시에 백엔드(DB 등)에 몰리는 현상입니다
- ❓어떤 상황에서 발생하나요?
  - 캐시 TTL 만료 후 순간 트래픽 집중
  - 서비스 최초 기동 or Redis 장애 후 복구 시
  - 비동기 캐시 갱신 실패 또는 느릴 때
- 캐시 전략에서 발생 가능성

| 캐시 전략 | 스탬피드 발생 가능성 | 설명 |
| --- | --- | --- |
| **Cache-aside (Look-aside)** | ✅ 매우 높음 | TTL 만료 시 요청마다 DB 접근 발생 가능 |
| **Write-through** | ❌ 낮음 | 항상 DB + 캐시에 동시 저장 → 빈 상태 거의 없음 |
| **Write-behind** | ✅ 가능 | 캐시에만 존재하다가 TTL 만료 시 데이터 공백 발생 가능 |

- 방지 방법
  - 적절한 만료시간 분산
  - Probabilistic Early Recomputation (PER) 알고리즘 사용하여 만료 전 미리 데이터를 갱신하여 요청 몰림을 방지
  ```
  if (currentTime - (timeToCompute × beta × log(rand())) > expiry) { 미리 재계산 }
  ```
  
### 세션 스토어로서의 Redis
- 세션이란?
  - 사용자의 로그인 상태 등 사용자별 상태 정보를 저장하는 저장소
  - 토큰을 키값으로 사용자의 정보를 redis에 hash 자료구조로 넣음
- Redis를 세션 스토어로 쓰는 이유
  - 다중 서버 환경에서 공유 세션 제공
  - 빠른 응답속도 및 확장성 제공
- 기존 방법 대비 Redis의 강점

| 방법 | 단점 |
| --- | --- |
| Sticky Session | 서버 장애 시 사용자 데이터 손실 |
| All-to-all 공유 | 불필요한 데이터 통신 증가 |
| RDBMS 사용 | 응답 속도 느림 |

- 세션과 캐시의 차이
  - 캐시: 성능 향상 목적, 데이터 유실 허용 가능성 높음
  - 세션: 사용자 상태 유지 목적, 데이터 일관성과 내구성이 중요