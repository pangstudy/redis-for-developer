# 10장: 레디스 클러스터

---

## 레디스 클러스터와 확장성

### 스케일업, 스케일 아웃

* **스케일업 (Scale Up)**: 서버의 성능을 높이는 방식 (CPU, 메모리 증설).
    * **장점**: 설정이 비교적 간단하고, 기존 애플리케이션 변경 없이 성능 향상 가능.
    * **단점**: 물리적인 한계가 명확하며, 비용이 많이 들고, 단일 장애점(SPOF)이 될 수 있음. 레디스의 경우, 모든 데이터가 하나의 노드에 존재하므로 메모리 한계에 직면할 수 있습니다. 예를 들어, 1TB 데이터를 저장하려면 1TB 이상의 메모리를 가진 서버가 필요하며 이는 매우 고가입니다.
* **스케일 아웃 (Scale Out)**: 여러 대의 서버를 추가하여 시스템을 확장하는 방식.
    * **장점**: 수평적 확장이 가능하여 무한대에 가까운 성능 확장이 가능하며, 장애 발생 시 다른 노드가 서비스를 이어받을 수 있어 고가용성이 보장됨. 비용 효율적.
    * **단점**: 시스템 복잡도가 증가하고, 데이터 일관성 유지 등 분산 시스템 특유의 문제가 발생할 수 있음.
    * **레디스 클러스터의 역할**: 레디스 클러스터는 레디스의 스케일 아웃을 가능하게 하는 공식적인 방법입니다. 데이터를 여러 노드에 분산 저장하고, 노드 장애 시 자동으로 복구하여 고가용성을 제공합니다.

**질문**: 스케일업과 스케일 아웃 중 어떤 방식이 레디스 클러스터의 주요 목표와 더 밀접하게 연관되어 있을까요? 그 이유는 무엇일까요?

## 레디스 클러스터의 기능

### 데이터 샤딩

* **설명**: 레디스 클러스터의 핵심 기능으로, 전체 데이터를 여러 노드에 분산하여 저장하는 것을 의미합니다. 이를 통해 단일 노드의 메모리 한계를 극복하고, 여러 노드에서 동시 처리하여 전체 처리량을 증가시킬 수 있습니다.
* **그림 10-2 예시 (가상의 시나리오)**:
    * **예시**: 사용자 정보(`user:100`, `user:200`), 상품 정보(`product:A`, `product:B`), 주문 정보(`order:X`, `order:Y`)가 있다고 가정합니다.
    * **데이터 샤딩 적용**:
        * Node A: `user:100`, `product:A`
        * Node B: `user:200`, `order:X`
        * Node C: `product:B`, `order:Y`
    * 이처럼 서로 다른 종류의 데이터나 같은 종류의 데이터를 일정한 기준(예: 해시 슬롯)에 따라 다른 노드에 분산 저장합니다.

### 고가용성

* **설명**: 클러스터 내의 노드 중 일부에 장애가 발생하더라도 서비스가 중단되지 않고 계속해서 작동할 수 있도록 보장하는 기능입니다. 각 마스터 노드에는 하나 이상의 복제본(Replica) 노드가 있어, 마스터 노드 장애 시 복제본이 자동으로 새로운 마스터로 승격됩니다.
* **그림 10-3 예시 (가상의 시나리오)**:
    * **초기 상태**:
        * Node A (Master) - Node A-Replica (Replica)
        * Node B (Master) - Node B-Replica (Replica)
        * Node C (Master) - Node C-Replica (Replica)
    * **장애 발생**: Node B (Master)에 장애 발생.
    * **페일오버**: Node B-Replica가 자동으로 새로운 마스터로 승격되어, 클라이언트 요청을 처리합니다. 클라이언트는 새로운 마스터로 리디렉션됩니다.
    * **결과**: 서비스 중단 없이 데이터에 접근 가능.

**질문**: 데이터 샤딩과 고가용성 기능은 서로 어떤 관계를 가지고 있으며, 레디스 클러스터에서 이 두 기능이 함께 제공되는 것이 중요한 이유는 무엇일까요?

## 레디스 클러스터 동작방법

### 해시슬롯을 이용한 데이터 샤딩

* **해시슬롯이란?**: 레디스 클러스터는 전체 키 공간을 16384개의 "해시 슬롯(Hash Slot)"으로 나눕니다. 각 데이터 키는 특정 해시 함수를 통해 0부터 16383 사이의 해시 슬롯 번호로 매핑됩니다.
* **해시 함수**: 클라이언트가 보내는 키에 대해 CRC16 해시 함수를 사용하여 해시 값을 계산합니다. 이 해시 값을 16384로 나눈 나머지가 해당 키가 속하게 될 해시 슬롯 번호가 됩니다.
    * $Hash\_Slot = CRC16(Key) \pmod{16384}$
* **16384개**: 이 숫자는 레디스 개발팀이 클러스터 크기, 성능, 복잡성 등을 고려하여 최적이라고 판단한 값입니다. 너무 적으면 샤딩 효율이 떨어지고, 너무 많으면 메타데이터 관리 오버헤드가 커집니다.
* **해시태그**: 특정 키들이 항상 같은 해시 슬롯에 할당되도록 강제하는 메커니즘입니다. 키에 `{...}` 형식으로 해시태그를 포함하면, 중괄호 안의 문자열만 사용하여 해시 슬롯을 계산합니다.
    * **예시**: `user:{123}:name`과 `user:{123}:email`은 모두 `{123}`을 해시태그로 가지므로 동일한 해시 슬롯에 할당됩니다. 이는 다중 키 커맨드(예: `MGET`, `MSET`)를 사용할 때 유용합니다.
* **다중 키 커맨드**: `MGET`, `MSET`, `DEL` 등 여러 키에 대해 한 번에 작업을 수행하는 커맨드입니다. 이 커맨드를 사용하려면 관련된 모든 키가 동일한 해시 슬롯에 있어야 합니다. 해시태그를 사용하면 이를 보장할 수 있습니다.
    * **예시**:
        ```
        MSET {user1}:name Alice {user1}:email alice@example.com
        ```
        `{user1}:name`과 `{user1}:email`은 모두 `{user1}`이라는 해시태그를 가지므로 같은 슬롯에 할당되고, `MSET` 명령이 정상적으로 수행됩니다.

**질문**: 해시 슬롯이 16384개인 이유는 무엇일까요? 이 숫자가 작거나 컸을 때 발생할 수 있는 잠재적인 문제점은 무엇일까요?

### 자동 재구성

* **페일오버**: 마스터 노드에 장애가 발생했을 때, 해당 마스터 노드의 복제본 중 하나가 자동으로 새로운 마스터로 승격되는 과정입니다.
    * **클러스터 페일오버 예시**:
        1.  클러스터의 다른 노드들이 장애가 발생한 마스터 노드를 감지합니다 (PFAIL -> FAIL 상태).
        2.  장애가 발생한 마스터 노드의 해시 슬롯을 담당할 새로운 마스터를 선출하기 위한 투표가 시작됩니다.
        3.  가장 적합한 복제본(최신 데이터를 가지고 있고, 연결 상태가 양호한)이 선택되어 마스터로 승격됩니다.
        4.  클라이언트들은 새로운 마스터 노드로 요청을 리디렉션 받습니다.
* **자동 복제본 마이그레이션**: 클러스터가 안정적인 상태를 유지하기 위해, 특정 마스터 노드의 복제본 수가 부족해지면, 다른 마스터 노드의 여유 복제본을 자동으로 이동시켜 해당 마스터의 복제본으로 할당하는 기능입니다. 이를 통해 복제본 부족으로 인한 가용성 저하를 방지합니다.

**질문**: 페일오버 과정에서 "가장 적합한 복제본"을 선출하는 기준은 무엇일까요? 또한, 자동 복제본 마이그레이션은 어떤 상황에서 주로 발생하며, 클러스터의 안정성에 어떻게 기여할까요?

## 레디스 클러스터 실행하기

### 최소 3개 마스터 노드

* 레디스 클러스터를 구성하려면 최소한 3개의 마스터 노드가 필요합니다. 이는 클러스터가 노드 장애를 감지하고 페일오버를 수행하는 데 필요한 쿼럼(과반수)을 확보하기 위함입니다. 일반적으로는 각 마스터 노드에 최소 1개의 복제본 노드를 두어 총 6개 노드(3 Master + 3 Replica)로 시작하는 것이 권장됩니다.

### 클러스터 초기화

* **예시 코드 및 설정 (redis.conf 예시)**:
    ```ini
    port 7000             # 각 노드의 포트 번호
    cluster-enabled yes   # 클러스터 모드 활성화
    cluster-config-file nodes-7000.conf # 클러스터 설정 파일 (자동 생성/관리)
    cluster-node-timeout 5000 # 노드 타임아웃 (밀리초)
    appendonly yes        # AOF 활성화 (데이터 지속성)
    ```
* **클러스터 생성 명령어 (redis-cli)**:
    ```
    redis-cli --cluster create 127.0.0.1:7000 127.00.1:7001 127.0.0.1:7002 \
    --cluster-replicas 1 # 각 마스터에 1개의 복제본 할당
    ```
    이 명령어는 지정된 노드들을 마스터로 설정하고, `--cluster-replicas 1` 옵션을 통해 각 마스터에 대해 하나의 복제본을 자동으로 할당하여 클러스터를 초기화합니다.

### 클러스터 상태 확인

* **예시 코드**:
    ```
    redis-cli -p 7000 cluster info
    ```
* **각 필드와 설명**:
    ```
    cluster_state:ok           # 클러스터 상태 (ok 또는 fail)
    cluster_slots_assigned:16384 # 할당된 해시 슬롯 수
    cluster_slots_ok:16384     # 정상적인 해시 슬롯 수
    cluster_slots_pfail:0      # PFAIL 상태의 해시 슬롯 수
    cluster_slots_fail:0       # FAIL 상태의 해시 슬롯 수
    cluster_known_nodes:6      # 클러스터 내에 알려진 총 노드 수
    cluster_size:3             # 마스터 노드의 수
    cluster_current_epoch:6    # 클러스터의 현재 에포크 (버전)
    cluster_my_epoch:2         # 현재 노드의 에포크
    cluster_stats_messages_sent:12345 # 주고받은 메시지 수
    cluster_stats_messages_received:12345 # 주고받은 메시지 수
    ```
    이 정보는 클러스터의 전반적인 건강 상태와 구성 정보를 제공합니다.

### redis-cli를 이용해 클러스터 접근하기와 리디렉션

* **`redis-cli -c` 옵션**: 클러스터 모드로 `redis-cli`에 접속하는 옵션입니다. 클라이언트가 잘못된 노드에 요청을 보내면, `redis-cli`가 자동으로 올바른 노드로 리디렉션해줍니다.
    ```
    redis-cli -c -p 7000
    ```
* **Redirected 메시지 예시**:
    ```
    127.0.0.1:7000> SET mykey "Hello"
    -> Redirected to slot 15495 residing at 127.0.0.1:7002
    OK
    ```
    `mykey`가 `7000`번 노드의 해시 슬롯에 속하지 않고, `7002`번 노드에 속하기 때문에 `redis-cli`가 자동으로 `7002`번 노드로 리디렉션한 것을 보여줍니다.
* **MOVED 에러**: `redis-cli -c` 옵션을 사용하지 않거나, 클라이언트 라이브러리가 클러스터 리디렉션을 지원하지 않을 경우, 잘못된 노드에 요청을 보내면 `MOVED` 에러가 반환됩니다. 이 에러 메시지에는 올바른 해시 슬롯 번호와 해당 슬롯을 담당하는 노드의 IP 주소 및 포트가 포함되어 있습니다. 클라이언트는 이 정보를 바탕으로 올바른 노드로 요청을 재전송해야 합니다.

**질문**: `redis-cli -c`와 같이 클라이언트 단에서 리디렉션을 처리하는 것과, 클라이언트 라이브러리가 직접 클러스터 토폴로지를 관리하며 요청을 올바른 노드로 보내는 방식 중 어떤 것이 더 효율적이라고 생각하며 그 이유는 무엇일까요?

## 페일오버 테스트

### 커맨드를 이용한 페일오버 발생 (수동 페일오버)

* `CLUSTER FAILOVER`: 특정 마스터 노드의 복제본에서 이 명령어를 실행하면, 해당 복제본이 강제로 새로운 마스터로 승격됩니다. 이는 테스트나 특정 상황에서 수동으로 페일오버를 유도할 때 사용됩니다.
    * **예시**: 마스터 7000의 복제본 7003에서 `redis-cli -p 7003 CLUSTER FAILOVER` 실행

### 마스터 동작을 중지시켜 페일오버 발생 (자동 페일오버)

* 가장 일반적인 페일오버 테스트 방법입니다. 특정 마스터 노드의 프로세스를 강제로 종료하거나 네트워크를 단절시켜 실제로 장애가 발생한 상황을 시뮬레이션합니다. 클러스터는 설정된 타임아웃(`cluster-node-timeout`) 이후 해당 노드를 `FAIL` 상태로 간주하고 자동 페일오버 과정을 시작합니다.
    * **예시**: `kill -9 <redis-server-pid>`

## 레디스 클러스터 운영하기

### 클러스터 리샤딩

* **설명**: 클러스터에 새로운 노드를 추가하거나 기존 노드를 제거할 때, 또는 특정 노드에 데이터가 불균형하게 할당되었을 때 해시 슬롯을 다른 노드로 이동시키는 작업입니다.
* **일부 해시슬롯 옮기는 예제 코드**: `redis-cli --cluster reshard` 명령을 사용합니다.
    ```
    redis-cli --cluster reshard 127.0.0.1:7000 \
    --cluster-from <source-node-id> \
    --cluster-to <target-node-id> \
    --cluster-slots <number-of-slots>
    ```
    이 명령은 특정 노드에서 다른 노드로 지정된 수의 해시 슬롯을 이동시킵니다.
* **클러스터 리샤딩 간단 버전**: `redis-cli --cluster reshard`를 실행하면 대화형 모드로 진입하여 어떤 슬롯을 어디로 옮길지, 몇 개의 슬롯을 옮길지 등을 단계별로 설정할 수 있습니다.

### 클러스터 확장 - 신규 노드 추가

* **마스터로 추가하기**: 새로운 노드를 마스터로 추가하고, 기존 마스터 노드의 일부 해시 슬롯을 새로운 마스터로 이동시킵니다.
    ```
    redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000
    # 7006번 노드를 7000번 노드가 속한 클러스터에 추가
    ```
    추가 후에는 리샤딩을 통해 새로운 노드에 해시 슬롯을 할당해야 합니다.
* **복제본으로 추가하기**: 기존 마스터 노드의 복제본으로 새로운 노드를 추가합니다.
    ```
    redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 \
    --cluster-slave --cluster-master-id <master-node-id>
    # 7006번 노드를 7000번 노드가 속한 클러스터에 복제본으로 추가하고, 특정 마스터에 연결
    ```

### 노드 제거하기

* **예제 코드**:
    ```
    redis-cli --cluster del-node 127.0.0.1:7000 <node-id-to-remove>
    ```
    노드를 제거하기 전에는 해당 노드가 가지고 있던 해시 슬롯을 다른 노드로 리샤딩하거나, 마스터 노드를 제거할 경우 해당 마스터의 복제본이 새로운 마스터로 승격되었는지 확인해야 합니다.
* `CLUSTER FORGET <node-id>`: 클러스터 내의 다른 모든 노드에게 특정 노드를 잊어버리도록 명령합니다. 주로 장애가 발생한 노드를 클러스터에서 완전히 제거할 때 사용됩니다.
* `CLUSTER RESET`: 특정 노드의 클러스터 관련 설정을 초기화하고, 해당 노드를 클러스터에서 분리합니다. 주로 클러스터 재구성이나 노드 재활용 시 사용됩니다. `SOFT`와 `HARD` 옵션이 있으며, `HARD`는 `cluster-config-file`까지 삭제합니다.

### 레디스 클러스터로의 데이터 마이그레이션

* **예제 코드**: `redis-cli --cluster import` 명령을 사용하여 외부 레디스 인스턴스 또는 RDB 파일에서 클러스터로 데이터를 가져올 수 있습니다.
    ```
    redis-cli --cluster import 127.0.0.1:6379 --cluster-target 127.0.0.1:7000 --cluster-replace
    ```
    이 명령은 기존 레디스 인스턴스(6379)의 데이터를 클러스터(7000)로 마이그레이션합니다. `--cluster-replace` 옵션은 대상 클러스터에 이미 존재하는 키를 덮어씁니다.

### 복제본을 이용한 읽기 성능 향상

* 레디스 클러스터의 복제본은 읽기 요청을 처리할 수 있습니다. 마스터 노드가 쓰기 요청에 집중하는 동안, 복제본은 읽기 요청을 분산 처리하여 전체 읽기 처리량을 향상시킬 수 있습니다.
* **주의**: 복제본은 비동기적으로 데이터를 동기화하므로, 복제본에서 읽는 데이터가 마스터의 최신 데이터보다 약간 오래되었을 수 있습니다 (일관성 지연). 애플리케이션 요구사항에 따라 이 점을 고려해야 합니다.

**질문**: 클러스터 리샤딩 작업은 서비스에 어떤 영향을 미칠 수 있으며, 리샤딩 중 발생할 수 있는 잠재적인 문제를 최소화하기 위한 방법은 무엇일까요?

## 레디스 클러스터 동작방법 (심화)

### 하트비트 패킷이란?

* 클러스터의 각 노드들은 주기적으로 다른 모든 노드들에게 "하트비트 패킷"을 주고받습니다. 이 패킷에는 클러스터의 현재 상태를 알리는 중요한 정보들이 포함되어 있습니다. 이를 통해 노드들은 서로의 건강 상태를 확인하고 클러스터의 일관성을 유지합니다.
* **노드 ID**: 각 노드를 고유하게 식별하는 40자의 16진수 문자열입니다.
* **현재 에포크/구성 에포크**: 클러스터의 전체 구성이 변경될 때마다 증가하는 버전 번호입니다. 에포크는 클러스터의 최신 상태를 나타내며, 노드 간의 합의에 사용됩니다.
* **노드 플래그**: 노드의 상태를 나타내는 플래그입니다 (예: `master`, `slave`, `PFAIL`, `FAIL`, `noaddr` 등).
* **비트맵 (해시 슬롯 소유 정보)**: 해당 노드가 어떤 해시 슬롯을 담당하고 있는지 비트맵 형태로 알려줍니다. 이를 통해 다른 노드들은 특정 키가 어느 노드에 있는지 알 수 있습니다.
* **TCP 포트**: 레디스 데이터 통신을 위한 포트입니다.
* **클러스터 포트**: 클러스터 내부 통신(하트비트, 페일오버 등)을 위한 포트입니다. 일반적으로 레디스 데이터 포트 + 10000으로 설정됩니다.
* **클러스터 상태**: `ok` 또는 `fail`과 같은 클러스터의 전반적인 건강 상태.
* **마스터 노드 ID (복제본의 경우)**: 해당 복제본이 어떤 마스터의 복제본인지 알려주는 마스터 노드의 ID.

### 해시슬롯 구성이 전파되는 방법

* **하트비트 패킷**: 가장 기본적인 방법입니다. 노드들은 하트비트 패킷을 통해 자신들이 담당하는 해시 슬롯 정보와 다른 노드들의 상태 정보를 주기적으로 전파합니다.
* **업데이트 메시지**: 클러스터 구성에 중요한 변경이 발생했을 때 (예: 페일오버, 리샤딩), 해당 변경을 모든 노드에 즉시 알리기 위해 업데이트 메시지가 전송됩니다. 이 메시지는 하트비트 패킷보다 더 긴급하게 처리됩니다.

### 노드 핸드셰이크

* `CLUSTER MEET <ip> <port>`: 새로운 노드를 클러스터에 추가할 때 사용하는 명령어입니다. 이 명령을 실행하면, 지정된 IP와 포트의 노드가 현재 클러스터에 참여하도록 요청하고, 클러스터의 다른 노드들과 정보를 교환하며 클러스터에 통합됩니다.
* **풀 메쉬 연결**: 레디스 클러스터의 모든 노드는 다른 모든 노드와 직접 TCP 연결을 맺습니다 (full mesh topology). 이를 통해 각 노드는 클러스터의 전반적인 상태를 직접 파악하고, PFAIL/FAIL 감지 및 페일오버 과정을 효율적으로 수행할 수 있습니다.

### 클러스터 라이브 재구성

* 레디스 클러스터는 서비스 중단 없이 노드를 추가, 제거하거나 리샤딩을 수행할 수 있습니다. 이는 클라이언트 리디렉션 메커니즘과 노드 간의 협력을 통해 가능합니다.
* **커맨드 예제**: 앞에서 설명한 `redis-cli --cluster add-node`, `redis-cli --cluster del-node`, `redis-cli --cluster reshard` 등이 모두 라이브 재구성을 위한 명령어입니다.

### 리디렉션

* **MOVED**: 클라이언트가 요청한 키가 다른 해시 슬롯에 속하여 현재 노드에 없는 경우 발생하는 에러입니다. `MOVED <hash_slot> <ip>:<port>` 형식으로 반환되며, 클라이언트는 이 정보를 바탕으로 올바른 노드로 요청을 재전송해야 합니다. 이 과정은 클라이언트 라이브러리에서 자동으로 처리되어야 합니다.
    * **구체적인 설명과 동작**: 클라이언트가 특정 키 `mykey`에 대해 `GET mykey`를 요청했는데, `mykey`가 127.0.0.1:7001에 있어야 하는 경우, 현재 연결된 127.0.0.1:7000 노드는 `MOVED 1234 127.0.0.1:7001`을 반환합니다. 클라이언트는 이 정보를 받아 127.0.0.1:7001로 다시 연결하여 `GET mykey`를 보냅니다. 클라이언트는 클러스터의 해시 슬롯 매핑 정보를 캐싱하여 이후에는 바로 올바른 노드로 요청을 보낼 수 있습니다.
* **ASK**: 리샤딩과 같이 해시 슬롯이 한 노드에서 다른 노드로 이동 중일 때 발생하는 임시적인 리디렉션입니다. `ASK <hash_slot> <ip>:<port>` 형식으로 반환됩니다. `MOVED`와 달리 `ASK`는 영구적인 변경이 아니므로, 클라이언트는 ASK 메시지를 받은 후 한 번만 해당 노드로 요청을 보내고, 다음 요청부터는 원래 노드로 돌아가야 합니다.
    * **구체적인 설명과 동작**: `ASK`는 특정 슬롯이 한 노드에서 다른 노드로 옮겨지고 있을 때 사용됩니다. 예를 들어, `slot X`가 Node A에서 Node B로 이동 중일 때, Node A는 `slot X`의 일부 키를 이미 Node B로 보냈을 수 있습니다. 클라이언트가 Node A에게 `slot X`에 속하는 키 `mykey`를 요청했는데, `mykey`가 이미 Node B로 이동했다면 Node A는 `ASK X 127.0.0.1:NodeB_Port`를 반환합니다. 클라이언트는 Node B에 `ASKING` 명령어를 먼저 보낸 후 `mykey`에 대한 요청을 보냅니다. `ASKING`은 Node B가 `slot X`에 대한 요청을 임시적으로 처리할 수 있도록 권한을 부여합니다.

**질문**: MOVED와 ASK 리디렉션의 차이점은 무엇이며, 클라이언트 라이브러리가 이 두 가지 에러를 어떻게 다르게 처리해야 할까요?

### 장애감지와 페일오버

* **PFAIL 플래그 (Potential Fail)**: 특정 노드가 다른 노드로부터 `cluster-node-timeout` 시간 동안 응답을 받지 못했을 때 설정되는 플래그입니다. 이는 해당 노드가 잠재적으로 다운되었을 가능성이 있음을 나타냅니다. PFAIL은 다른 노드들에게 해당 노드의 상태를 주시하도록 알리는 역할을 합니다.
* **FAIL 플래그**: 클러스터 내의 충분한 수의 노드(과반수)가 특정 노드를 PFAIL 상태로 보고했을 때, 해당 노드는 `FAIL` 상태로 선언됩니다. `FAIL` 상태는 해당 노드가 확실히 다운되었음을 의미하며, 이 시점에서 해당 노드가 마스터인 경우 페일오버 절차가 시작됩니다.

### 복제본 선출

* **복제본 선출 과정**: 마스터 노드가 `FAIL`로 선언되면, 해당 마스터의 복제본 중 하나가 새로운 마스터로 승격되어야 합니다. 이 과정은 다음과 같은 단계를 거칩니다.
    1.  `FAIL` 상태의 마스터의 복제본들이 자신들이 새로운 마스터가 될 자격이 있다고 판단하면, 다른 노드들에게 투표를 요청합니다.
    2.  가장 많은 투표를 받은 복제본이 새로운 마스터로 선출됩니다. 투표 과정에서는 다음 조건들을 고려합니다:
        * **짧은 딜레이**: 마스터와의 통신 지연이 짧은 복제본이 우선적으로 고려됩니다.
        * **최신 데이터**: 마스터로부터 가장 최신 데이터를 복제한 복제본이 우선적으로 선택됩니다. 이는 `repl_offset` 값을 통해 판단됩니다.
        * **투표**: 각 노드는 한 번의 에포크에서 한 번만 투표할 수 있습니다. 과반수의 투표를 얻은 복제본이 마스터로 승격됩니다.
    3.  새로운 마스터가 선출되면, 클러스터의 다른 노드들에게 새로운 마스터의 정보를 전파하여 클러스터의 구성이 업데이트됩니다.

**질문**: `cluster-node-timeout` 설정이 레디스 클러스터의 장애 감지 및 페일오버 시간에 어떤 영향을 미칠까요? 이 값을 너무 짧게 또는 너무 길게 설정했을 때 발생할 수 있는 문제점은 무엇일까요?