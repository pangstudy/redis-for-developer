# 11장: 레디스 보안

---

## Redis 보안의 필요성
- Redis는 빠르고 효율적인 인메모리 데이터베이스지만 기본적인 보안 설정이 부족합니다.
- 비밀번호 인증, IP 제한, SSL/TLS 암호화 등 추가적인 보안 설정이 필요합니다.
- Redis를 안전하게 운영하기 위해서는 외부 공격 및 내부 실수로 인한 보안 취약점을 방지해야 합니다.

### Redis 보안 취약점
- 기본 인증 미제공: 기본적으로 인증을 요구하지 않음.
- 네트워크 보안 문제: 기본 포트(6379)가 외부에 노출될 경우 악용될 수 있음.
- 위험한 명령어: FLUSHALL, CONFIG와 같은 명령어가 시스템에 큰 영향을 미침.

### Redis 보안 설정 방법

#### 비밀번호 인증
- Redis는 기본적으로 인증을 요구하지 않지만, requirepass를 설정하여 비밀번호 인증을 요구할 수 있습니다.

```
requirepass <비밀번호>
```

#### 클라이언트 IP 제한
- bind 설정을 사용하여 Redis가 수신할 IP를 제한할 수 있습니다.

```
bind 127.0.0.1
```
- 이 설정은 Redis가 로컬에서만 접근을 허용하게 만듭니다.

#### 포트 번호 변경
- Redis는 기본적으로 포트 6379에서 실행됩니다. 이를 변경하여 기본 포트를 숨길 수 있습니다.

```
port 6380
```

#### Redis 서버의 방화벽 설정
- Redis 서버가 외부에서 접근하지 않도록 방화벽을 설정할 수 있습니다. 예를 들어, Redis는 특정 IP에서만 접근을 허용할 수 있습니다.

### SSL/TLS 암호화
- Redis는 기본적으로 암호화되지 않은 통신을 사용하지만, SSL/TLS를 통해 암호화된 통신을 설정할 수 있습니다.
- SSL/TLS 암호화는 인터넷에서 데이터를 안전하게 전송하기 위해 사용되는 프로토콜입니다. SSL(Secure Sockets Layer)은 과거에 사용되던 프로토콜로, 현재는 TLS(Transport Layer Security)로 발전했으며, 둘은 동일한 개념으로 사용되기도 합니다. 사실, TLS는 SSL의 후속 프로토콜로, SSL에서 발견된 여러 가지 보안 취약점을 해결한 프로토콜입니다.

```
tls-port 6379
tls-cert-file /path/to/cert.pem
tls-key-file /path/to/key.pem
tls-ca-cert-file /path/to/ca.pem
```

#### SSL/TLS 암호화의 개요
- SSL/TLS는 전송 계층 보안(TLS) 프로토콜을 사용하여 클라이언트와 서버 간의 데이터를 암호화합니다. 이 프로토콜은 대칭키 암호화와 비대칭키 암호화를 결합하여 사용하며, 그 목적은 데이터 기밀성, 무결성, 인증을 보장하는 것입니다.

#### 암호화 알고리즘
- 대칭키 암호화
  - AES (Advanced Encryption Standard): 가장 일반적으로 사용되는 대칭키 암호화 알고리즘입니다. 128비트, 192비트, 256비트 키 크기를 지원합니다.
  - 3DES (Triple DES): DES 알고리즘을 3번 적용한 방식으로, 구식이지만 일부 오래된 시스템에서 사용됩니다.

- 비대칭키 암호화
  - RSA (Rivest–Shamir–Adleman): 가장 널리 사용되는 비대칭키 암호화 알고리즘으로, 서버의 공개키를 사용하여 데이터를 암호화하고, 서버는 해당 개인키로 이를 복호화합니다.
  - ECC (Elliptic Curve Cryptography): RSA보다 더 적은 키 크기로도 동일한 보안 수준을 제공하는 비대칭 암호화 방식입니다. 성능이 뛰어나며, 모바일 기기나 IoT 기기에서 많이 사용됩니다.

- 해시 함수
  - HA (Secure Hash Algorithm): 데이터의 무결성을 검증하는 데 사용됩니다. TLS에서 가장 많이 사용되는 해시 알고리즘은 SHA-256입니다.

- 메시지 인증 코드 (MAC)
  - HMAC (Hash-based Message Authentication Code): 데이터의 무결성을 보장하고 변조를 방지하는 데 사용됩니다. TLS에서는 HMAC을 SHA 알고리즘과 결합하여 메시지의 무결성을 확인합니다.

#### SSL/TLS 핸드셰이크 과정

- **1단계: 클라이언트 헬로(Client Hello)**
- 클라이언트는 서버에 연결을 요청하며, 이때 Client Hello 메시지를 서버로 전송합니다.
- 메시지에는 다음 정보가 포함됩니다:
  - SSL/TLS 버전
  - 암호화 알고리즘 목록(클라이언트가 지원하는 알고리즘)
  - 랜덤 값 (Client Random)
  - 세션 ID (새로운 세션일 경우 없을 수 있음)

- **2단계: 서버 헬로(Server Hello)**
- 서버는 클라이언트의 요청에 응답하며 Server Hello 메시지를 반환합니다.
- 메시지에는 다음 정보가 포함됩니다:
  - 서버가 선택한 SSL/TLS 버전
  - 서버가 선택한 암호화 알고리즘
  - 랜덤 값 (Server Random)
  - 서버의 인증서(서버가 사용하는 공개키와 그에 대한 정보 포함)

- **3단계: 서버 인증 및 키 교환**
- 서버는 자신의 인증서를 클라이언트에 전달하여 자신이 누구인지 인증합니다. 클라이언트는 이를 확인하여 신뢰할 수 있는 인증 기관(CA)으로부터 발급받았는지 검증합니다.
- 서버가 인증서를 전송한 후, Pre-Master Secret을 생성할 수 있도록 클라이언트에게 비대칭키 암호화 방식(RSA 또는 ECC)을 사용하여 전송할 수 있습니다.
- 이 때, 서버는 클라이언트가 보낸 데이터를 복호화할 수 있는 개인키를 사용해 Pre-Master Secret을 생성합니다.

- **4단계: 클라이언트 키 교환**
- 클라이언트는 서버의 공개키를 사용해 Pre-Master Secret을 암호화하여 서버에 보냅니다.
- 서버는 이를 복호화하여, 클라이언트와 동일한 Pre-Master Secret을 얻습니다.

- **5단계: 세션 키 생성**
- 클라이언트와 서버는 Pre-Master Secret과 클라이언트 랜덤값(Client Random), 서버 랜덤값(Server Random)을 결합하여 세션 키를 생성합니다.
- 세션 키는 대칭키 암호화를 사용하여 실제 데이터를 암호화하고 복호화하는 데 사용됩니다.

- 6단계: 핸드셰이크 완료
- 클라이언트와 서버는 각각 Finished 메시지를 교환합니다.
- 이 메시지는 핸드셰이크가 성공적으로 완료되었음을 나타냅니다. 이후 클라이언트와 서버는 세션 키를 사용하여 암호화된 데이터를 안전하게 전송할 수 있습니다.

#### SSL/TLS 암호화 동작 흐름
- 핸드셰이크가 완료되면, 클라이언트와 서버는 대칭키 암호화 방식으로 세션 키를 사용하여 데이터를 암호화하고 복호화합니다.
- 데이터 전송: 클라이언트와 서버 간의 데이터는 세션 키로 암호화되어 안전하게 전송됩니다.
- 세션 종료: 세션이 종료되면, 세션 키는 폐기됩니다.

#### Redis 보안 구성 예시

```
# 인증 설정
requirepass mysecretpassword

# 클라이언트 IP 제한
bind 127.0.0.1

# 외부 연결 방지
protected-mode yes

# SSL/TLS 설정 (Redis 6 이상)
tls-port 6379
tls-cert-file /path/to/cert.pem
tls-key-file /path/to/key.pem
tls-ca-cert-file /path/to/ca.pem
```

#### 보호 모드 (Protected Mode)
- 보호 모드란?
  - Redis는 기본적으로 보호 모드가 활성화되어 있어 설정이 제대로 되어 있지 않으면 외부에서 접근을 차단합니다. 이 모드는 Redis가 외부에 노출되지 않도록 안전하게 운영하는 데 유용합니다.

#### Redis 명령어 보호
- Redis에서 FLUSHALL, CONFIG와 같은 명령어는 시스템에 큰 영향을 미칠 수 있습니다.
- rename-command를 사용하여 명령어 이름을 변경하거나 비활성화할 수 있습니다.

```
rename-command FLUSHALL ""
rename-command CONFIG ""
```

### Redis 보안 모니터링

#### Redis 모니터링
- Redis는 MONITOR 명령어를 통해 실시간으로 서버의 요청을 추적할 수 있습니다. 이를 통해 보안 감사를 수행하거나 이상 징후를 실시간으로 추적할 수 있습니다.