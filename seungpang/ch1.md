# 마이크로서비스 아키텍처와 레디스

##  데이터 저장소 요구 사항의 변화

기존 모놀리틱 서비스에서는 RDBMS가 표준처럼 사용되어 왔습니다. 이는 "중앙집중형" 구조에서 한눈에 관리되는 관계형 데이터베이스의 특성과 맞물려 운영상의 일관성과 관리의 용이성을 제공했습니다.

그러나 최근에는 비정형 데이터의 증가와 서비스 구조의 다양화로 인해 관계형 데이터베이스만으로는 한계가 있습니다. 특히 다차원적, 깊은 계층 구조의 데이터를 정형 테이블로 관리하기 어려운 경우가 많아졌습니다.

## NoSQL이란?

NoSQL은 "Not Only SQL"의 약어로 관계형 데이터베이스 외 다양한 비정형 데이터를 저장하고 처리할 수 있는 데이터베이스들을 통칭합니다.

### NoSQL의 특성

* 실시간 응답: 수 ms 이내 응답 시간 보장
* 수평 확장성: 이벤트 폭주에도 유연하게 대응
* 고가용성: 장애 복구 속도 우수
* 클라우드 네이티브: 클라우드 환경에 최적화
* 단순성: 사용 모델이 간단함
* 유연성: 스키마가 없거나 유연하게 정의 가능

## NoSQL의 유형

### 문서(Document) 유형

* JSON 또는 BSON 형태로 데이터를 저장
* 스키마가 유연해 빠르게 애플리케이션 구조에 맞춰 변경 가능
* MongoDB, Amazon DocumentDB 등이 대표적

### 키-값(Key-Value) 유형

* 단순한 구조로 빠른 응답성과 수평 확장성이 뛰어남
* 세션, 캐시, 로그 등 고속처리가 필요한 곳에 적합
* Redis, DynamoDB, Memcached 등

### 컬럼(Column-Family) 유형

* 열 기반 저장으로 대량 데이터 분석과 집계에 최적화
* Apache Cassandra, HBase 등이 대표적

Q. 컬럼 기반이면 RDBMS랑 뭐가 다른가요?
> RDB는 행 기반 저장으로 단일 레코드 중심 처리에 유리한 반면, 컬럼 기반은 일부 컬럼만 반복 조회하는 분석용에 매우 빠릅니다.

### 그래프(Graph) 유형

* 노드와 엣지로 관계를 저장
* 친구, 팔로우, 추천 시스템 등 관계 중심 구조에 강점
* Neo4j, Amazon Neptune 등

Q. sns와 같은 곳에서 친구목록에 적합할까요?
> 관계형 탐색이 많은 구조에 매우 적합하며 그래프 탐색 알고리즘을 바로 활용할 수 있습니다.

## 레디스 특징

Redis(Remote Dictionary Server)는 대표적인 In-Memory Key-Value NoSQL 데이터베이스입니다.
* **빠른 응답성**: 디스크 접근이 아닌 RAM에서 직접 데이터를 처리
* **다양한 자료구조 지원**: String, Hash, Set, List, SortedSet, Stream 등
* **임피던스 불일치 해소**: 애플리케이션과 DB 간 구조 차이 감소
* **단순성**: Key-Value 구조 기반으로 쉽고 직관적

### 싱글 스레드 기반 구조

* 메인 스레드 1개 + 내부 보조 스레드
* CPU가 적어도 빠른 응답 보장
* **주의**: 하나의 명령어가 오래 걸리면 전체 대기 발생 가능 (blocking)

> Q. 서비스 중 `SAVE`, `BGSAVE` 사용하면 안 되는 이유는?
> `SAVE`는 전체 Redis를 블로킹하고, `BGSAVE`는 메모리 사용량이 급증할 수 있어 트래픽 중에는 사용 금지 권장

Q. `KEYS *` 명령어는 왜 위험한가요?
> 전체 키를 순회하는 구조라 데이터가 많으면 Redis를 멈출 수 있습니다. `SCAN` 명령어로 대체해야 함


## MSA 아키텍처와 Redis

### 데이터 저장소로서의 레디스

* **AOF(Append Only File)**: 모든 변경 로그를 기록해 복구 가능
* **RDB(Snapshot)**: 일정 조건에 따라 전체 덤프 저장
* 설정은 redis.conf에서 지정 가능

```ini
save 900 1 // 15분 이내에 1건 이상 변경되면 저장
save 300 10 // 5분 내에 10건 이상 변경되면 저장

appendonly yes
appendfsync everysec
```

Q. RDB의 동작 방식은?
> 일정한 조건(시간 + 변경 횟수)에 따라 Redis 전체 데이터를 덤프 파일(dump.rdb)로 저장합니다.
> redis는 이 덤프 파일을 백그라운드에서 생성합니다.

Q. AOF의 동작 방식은?
> Redis는 수정/삭제/추가 등의 모든 write 명령을 순차적으로 로그 파일에 기록합니다.
> Redis가 재시작되면 이 AOF 파일을 위에서부터 순서대로 재실행해서 데이터를 복원합니다.

| 항목             | AOF                | RDB                  |
| -------------- | ------------------ | -------------------- |
| **데이터 손실 가능성** | 1초 이하로 최소화 가능      | 마지막 스냅샷 이후 데이터 손실 가능 |
| **복구 속도**      | 느림 (명령어 실행 기반)     | 빠름 (메모리 상태 복사)       |
| **디스크 사용량**    | 큼                  | 작음                   |
| **사람이 읽기 쉬움**  | 예 (텍스트 로그)         | 아니오 (바이너리)           |
| **백업 타이밍**     | 실시간 또는 주기적         | 설정된 시점마다 스냅샷         |
| **운영 중 성능 영향** | 더 큼 (쓰기 작업이 많을 경우) | 적음 (백그라운드 처리)        |

### 메시지 브로커로서의 레디스

레디스의 pub/sub 기능이나 list 자료 구조, stream 자료 구조를 통해 각각 메시징 기능이나 메시징 큐, 스트림 플랫폼으로 활용 가능합니다.
실제로 레디스 pub/sub을 이용하여 알림을 개발해본 경험이 있습니다.
